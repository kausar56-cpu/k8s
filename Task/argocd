C:\Terraform\terraform.exe -version

install kiro - set up it - go to aws community - create asw bulider ID 
pass -%AUCNC_a45ckkm:
ygmind17
builder.aws.com/community/@ygmind17

new pass -  Kausar@#$12





================================================================================================================

---I worked on an e-commerce application for a client, which included a frontend on Spring Boot Java built using Maven, a backend on Node.js, Go Lang, a  database- MySQL, and PostgreSQL DynamoDB 
cashing using redis infa using terraform
-------------------------------------------------------------------------------------------------------------------------------
resource "time_sleep" "wait_for_cluster" {
  create_duration = "30s"
  depends_on = [
    module.retail_app_eks,
    module.eks_addons
  ]
}

time_sleep -  is a Terraform resource that pauses for a given amount of time

It waits for 30 seconds here.

Until then, it waits for both the retail_app_eks and eks_addons modules to complete (depends_on).
---------------------------------------------------------------------------------------------------------



resource "helm_release" "argocd" {
  name             = "argocd"
  namespace        = var.argocd_namespace
  create_namespace = true


helm_release is the resource used to install Helm charts.

A Helm release is created with the name ArgoCD.

It is installed in a specific namespace.

If the namespace does not already exist, create_namespace = true creates it automatically.

---------------------------------------------------------------------------------------------------


  repository = "https://argoproj.github.io/argo-helm"
  chart      = "argo-cd"
  version    = var.argocd_chart_version

ArgoCD's official Helm repository used to download Helm charts.

The chart argo-cd is used.

The version is taken from the variable argocd_chart_version.
-----------------------------------------------------------------------------------------------
  values = [
    yamlencode({
Custom settings are provided in YAML format using yamlencode
-----------------------------------------------------------------------------------------------------
      server = {
        service = {
          type = "ClusterIP"
        }
        ingress = {
          enabled = false
        }
        extraArgs = [
          "--insecure"
        ]
      }

service.type = ClusterIP means this service can only be used within the cluster (not from outside).

ingress.enabled = false means we will not use ingress. We will be viewing the UI with port-forward.

--insecure means the UI will work even without HTTPS – convenient for local development.
------------------------------------------------------------------------------------------------------
      controller = {
        resources = {
          requests = {
            cpu    = "100m"
            memory = "128Mi"
          }
          limits = {
            cpu    = "500m"
            memory = "512Mi"
          }
        }
      }
The controller pod is given the minimum (requests) and maximum (limits) CPU and RAM to be allocated.
------------------------------------------------------------------------------------------------------
      repoServer = {
        resources = {
          requests = {
            cpu    = "50m"
            memory = "64Mi"
          }
          limits = {
            cpu    = "200m"
            memory = "256Mi"
          }
        }
      }
Resource limits are given for the repoServer pod that connects 
to the Git repository.Resource limits are given for the repoServer pod that connects to the Git repository.
----------------------------------------------------------------------------------------------------------------
      redis = {
        resources = {
          requests = {
            cpu    = "50m"
            memory = "64Mi"
          }
          limits = {
            cpu    = "200m"
            memory = "128Mi"
          }
        }
      }
CPU and RAM resource configuration assigned to the Redis pod.
---------------------------------------------------------------------------------------------------------------------
  depends_on = [time_sleep.wait_for_cluster]
}
The cluster must be created before ArgoCD can be installed, so depends_on.
----------------------------------------------------------------------------------------------------------------------
resource "time_sleep" "wait_for_argocd" {
  create_duration = "60s"
  depends_on      = [helm_release.argocd]
}
After ArgoCD is installed, it waits for 60 seconds so that all ArgoCD pods are created.
-----------------------------------------------------------------------------------------------------------------
resource "null_resource" "argocd_apps" {
  depends_on = [time_sleep.wait_for_argocd]

ArgoCD uses null_resource to install Apps (Projects and Applications).

This should be run only after ArgoCD is created, hence depends_on.
---------------------------------------------------------------------------------------------------
  provisioner "local-exec" {
    command = <<-EOT
      echo "Deploying ArgoCD projects and applications..."
      kubectl apply -n ${var.argocd_namespace} -f ${path.module}/../argocd/projects/
      kubectl apply -n ${var.argocd_namespace} -f ${path.module}/../argocd/applications/
      echo "ArgoCD applications deployed successfully!"
    EOT
  }
The command is run from the local machine using local-exec.

YAML files are applied from the projects/ and applications/ folders in the ArgoCD namespace.
----------------------------------------------------------------------------------------------------
  triggers = {
    argocd_version = var.argocd_chart_version
    timestamp      = timestamp()
  }
}
This block needs to be triggered again.

If the ArgoCD version changes or the timestamp changes, null_resource will be applied again.
------------------------------------------------------------------------------------------------
Waiting for cluster to be created
➤ Waits 30 seconds for EKS and Add-ons to be created.

Installing ArgoCD (with Helm chart)
➤ Uses argoproj's Helm chart
➤ Creates a service of type ClusterIP
➤ Can use HTTP with --insecure mode (without HTTPS)
➤ CPU/Memory resource limits are set for each component (controller, repoServer, redis)

Waiting for ArgoCD to become stable
➤ Waits for 60 seconds — ArgoCD pods may take time to create

Deploying applications and projects from ArgoCD
➤ YAML files are applied using kubectl apply
➤ path: ../argocd/projects/ and ../argocd/applications/
➤ These YAML files contain your GitOps apps

Update detection using triggers
➤ If the chart version or timestamp changes, it is re-applied.
--------------------------------------------------------------------------------------------------


================================================================================================================================================

Why use locals in Terraform?
==========================
Avoid repetition – Define a value once and reuse it.

Improve readability – Makes your code cleaner and easier to understand.

Simplify updates – Change in one place reflects everywhere it's used.

Support complex logic – You can compute values using expressions


locals {
  cluster_name = "${var.cluster_name}-${random_string.suffix.result}"
}

------------------
local.cluster_name
-----------------------------------------------------------------------------------------------------------------------------------------

What is data in Terraform?
-=========================
data blocks are used to read existing information from your infrastructure — instead of creating something new.

eg.
Get AWS region info	      data "aws_region" "current" {}

Get current user/account	data "aws_caller_identity" "current" {}

Get availability zones	      data "aws_availability_zones" "available" {}
-----------------------------------------------------------------------------------------------------------------------------

What are EKS Add-ons?
========================
EKS add-ons are extra tools or extensions that improve your Kubernetes cluster by adding functionality like:

Load balancing

Ingress (routing traffic)

SSL certificates

Monitoring

Logging

Security
-----------------------------------------------------------------------------------
version.tf
==============



terraform {
  required_version = ">= 1.0"


➡️ This says:
Terraform must be version 1.0 or newer to run this code.

--------------------------------------------------------------------------------------------------------


  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 5.0"


➡️ Use the **AWS provider** from **HashiCorp**, version 5.0 or newer.
This lets Terraform manage AWS resources.

--------------------------------------------------------------------------------------------------------------------------------------------


    helm = {
      source  = "hashicorp/helm"
      version = ">= 2.0"
    }


➡️ Use the **Helm provider**, version 2.0 or newer.
Helm is used to install apps into Kubernetes.
--------------------------------------------------------------------------------------------------------------------------------------------------------




    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.0"
    }


➡️ Use the **Kubernetes provider**, version 2.0 or newer.
This lets Terraform manage Kubernetes resources (like pods, services).

----------------------------------------------------------------------------------------------------------------------------------------------


    time = {
      source  = "hashicorp/time"
      version = ">= 0.9"
    }


➡️ Use the **Time provider**, to do time-based actions (like wait, timestamps).

-----------------------------------------------------------------------------------------------------------------------------------



    null = {
      source  = "hashicorp/null"
      version = ">= 3.0"
    }


➡️ Use the **Null provider** — it helps run custom scripts or commands.

------------------------------------------------------------------------------------------------------------------------------


    random = {
      source  = "hashicorp/random"
      version = ">= 3.0"
    }
  }
}


➡️ Use the **Random provider**, to generate random values (like random names or passwords).

--------------------------------------------------------------------------------------------------------------------------


 SECTION: Provider Configurations




 1️⃣ AWS Provider


provider "aws" {
  region = var.aws_region
}


➡️ This tells Terraform to connect to **AWS in the region** you set in your `variables.tf` file (like `ap-south-1`).

-----------------------------------------------------------------------------------------------------------------------


### 2️⃣ HELM Provider


provider "helm" {
  kubernetes {
    host                   = module.retail_app_eks.cluster_endpoint
    cluster_ca_certificate = base64decode(module.retail_app_eks.cluster_certificate_authority_data)



➡️ This connects Helm to your **EKS Kubernetes cluster**.

----------------------------------------------------------------------------------------------------------


`host`: the cluster URL
 `cluster_ca_certificate`: the certificate needed to trust the cluster

---

`
    exec {
      api_version = "client.authentication.k8s.io/v1beta1"
      command     = "aws"
      args        = ["eks", "get-token", "--cluster-name", module.retail_app_eks.cluster_name]
    }
  }
}
```

➡️ This uses AWS CLI to **get an authentication token** to access your cluster.


----------------------------------------------------------------------------------------------------------

---

### 3️⃣ KUBERNETES Provider


provider "kubernetes" {
  host                   = module.retail_app_eks.cluster_endpoint
  cluster_ca_certificate = base64decode(module.retail_app_eks.cluster_certificate_authority_data)
`

➡️ This is **same as Helm**, but now Terraform will manage **Kubernetes resources** directly (like services, deployments, etc.)

----------------------------------------------------------------------------------------------------------------------------------------


  exec {
    api_version = "client.authentication.k8s.io/v1beta1"
    command     = "aws"
    args        = ["eks", "get-token", "--cluster-name", module.retail_app_eks.cluster_name]
  }
}
```

➡️ Again, this connects using AWS CLI token to access EKS.

------------------------------------------------------------------------------------------------------------------------
========================================
======================================================
app/chart
============

.dockerignore
==============

This file tells Docker which files/folders to skip when building an image.

It helps avoid adding unwanted or sensitive data, like .git/, which can increase image size.
-----------------------------------------------------------------------------------------------------------------

chart.yaml
=========
------------------------------------------------------------------------------------------------
| Alias      | Chart Name                           | Path                   |
| ---------- | ------------------------------------ | ---------------------- |
| `cart`     | `retail-store-sample-cart-chart`     | `../../cart/chart`     |
| `catalog`  | `retail-store-sample-catalog-chart`  | `../../catalog/chart`  |
| `checkout` | `retail-store-sample-checkout-chart` | `../../checkout/chart` |
| `orders`   | `retail-store-sample-orders-chart`   | `../../orders/chart`   |
| `ui`       | `retail-store-sample-ui-chart`       | `../../ui/chart`       |
--------------------------------------------------------------------------------------------------------------


values-stateful.yaml
===================
This YAML file defines configurations for multiple microservices: cart, catalog, checkout, and orders.
Each service specifies its required storage system (like DynamoDB, MySQL, Redis, or PostgreSQL) and whether to create it
---------------------------------------------------------------------------------------------------------------------------

values.yaml
===========

What is fullnameOverride used for?
===================================
The fullnameOverride field in a Helm chart is used to manually override the full name of Kubernetes resources created by the chart.

for eg.
==========
suppose your Helm chart name is onlineshop and the release name is prod.
Normally, the resource name would become something like prod-onlineshop-cart.

But if you set:
fullnameOverride: carts
Then the resource (like Deployment, Service) will be named simply carts.
----------------------------------------------------------------------------------------------------------------------------------





clone repo
cd terraform
terraform init
[note - first vpc will crete - EKS -AGgocd - application deployed]
--------------------------------------------------------------------
Here, we have numerous files. If I try applylly directly (terraform apply), then it will not connect with each other, 
for that reason, We have to create one by one 
-----------------------------------------------------------------------------------------------------------
first we are going to create VPC -  
=============================
cd terraform
terraform init
terraform plan -target="module.vpc"
terraform apply -target="module.vpc"
-----------------------------------------------------------------------------------------
version.tf
[Note - by using a provider, we can create a resource. Let's suppose we have an AWS-provided resource, 
and we can create a resource like that we are going to take helm, k8s, time, random,null, in that we mentioned 
Helm provider should work on EKS cluster, and in K8s our cluster should be created. ]
-----------------------------------------------------------------------------------------------------------------
security.tf 
in prod which https trafic shoud be route we have mention heare
-------------------------------------------------------------------------------------------
now EKS 
============
terraform apply -target="module.retail_app_eks"
------------------------------------------------
[note - each microservises have values.yaml this is very imp . we have just check templates 
and according to taht we can change value in value.yaml we are not using heare k8s yaml we are using charts]
------------------------------------------------------------------------------------------------------------
{we have helm charts{IMAGES} in src folder que is - how to connect to the our cluster ans is by using ARGOCD}
HOW? - SEE ARGOCD - retail-store-ui.yaml - - path: src/ui/chart - and in chart we have all values        ------VIMP
-----------------------------------------------------------------------------------------------------------
now try to connect cluster
aws eks update-kubeconfig --region us-west-2 --name retail-store-qmug
kubectl get nodes - i will show u null becoz - automode
kubectl create ns demo-nginx
kubectl run nginx --image=nginx --port=80 -n demo-nginx
kubectl get nodes -n  demo-nginx
kubectl get pods -n  demo-nginx
-------------------------------------------------------
after this - if we are try to give command only without target terraform apply then rest 
resources will be created and else will refresh only                 -------imp
---------------------------------------------------------------------------------------------
now we are going to create argocd, ingress,helm by using terraform apply command
note - we are going to use ingress controll so automaticaly in BE ALB will create
---------------------------------------------------------------------------------
output should be - Plan: 16 to add, 27 to change, 0 to destroy.
Whatever things we need to be an extra, we have to  add in addons.tf 
------------------------------------------------------------------------------------- 

Argocd makes a retail store sample application.
 Its code is available through 'https://github.com/LondheShubham153/retail-store-sample-app'.
 In retail ns above that all applications are available ---- see argocd folder
-----------------------------------------------------------------------------------------------

argocd_admin_password = <sensitive>
argocd_namespace = "argocd"
argocd_server_port_forward = "kubectl port-forward svc/argocd-server -n argocd 8080:443"
kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath="{.status.loadBalancer.ingress[0].hostname}" 
kubectl get pods -A



wsl --install
wsl --update
-----------------------------------------------------------------------------
Let's suppose we have the version 1 and currently version 1 is not working now I want to switch on version 2 so 
how we can deploy in a single go with version 2 so in that case we have to use GitOps.























