cluster IP 

developer gives an task to test the application's local env  
Cluster IP does have also the capability to rout traffic to different pods  
it can balance load accordingly it follows round the Robin method  
route traffic across multiple pods by using iptables
-----------------------------------------------------------------------------------------
node port

if we create a node port think cluster IP, not cluster IP present at backend 
uniq host port will create between 30000:32667 
we can create anyone special yes we can during manifest yaml file 
deport do dating internally once this part is done it will write to the cluster IP 
------------------------------------------------------------------------------------------
node port is not a use case for production application 
load balancing is good for production customer/users - we cannot give public IP: port 
Every time they are going to remember this 
------
So we are supposed to give the proper DNS name - domain name.  
------------------------------------------------------------------------------------------------
external name     --------------------------vimp

I am working on k8s application - and suddenly product manager came - can u integrate the database into the K8s application  - this is an external database not from another region 
this database accesses all teams because 
it contains product info
customer feedback 
reviews
---------------------
adv. of integrating database to k8s is databasehavinghostnamem , unique URL  
database admin - he came back toDevOpss guy - we are migrating the database server to another server  
next timeURLl and hostname are integrated with many applications 29 -After after migration hostname and URL will change -  
devops engg don't need to change the manual 29 application hostname and URL 
simple devops engg change the host name and URL in the external name 
it will be applied rest all application 
---------------------------------------------------------------------------------------------------------------------------------------------------------------
cluster IP 


kubectl create deployment app1 --image kiran2361993/loadbalncerimage:v1 --replicas 3 --dry-run -o  y

apiVersion: apps/v1
kind: Deployment
metadata:
  name: app1
  Labels: 
    app: app1
Spec: 
  replicas: 3
  Selector: 
    matchLabels:
      app: app1
  Template: 
    Metadata: 
      Labels: 
        app: app1
    Spec: 
      Containers: 
        - name: load balancer image 
          image: kiran2361993/load balancer image:v1 
apply it
--------------------------------
expose it 
kubectl expose deployment app1 --port 80 --target-port 80 --type ClusterIp

kubectl run troubleshooting --image=kiran2361993/troubleshootingtools:v1

login in that and access the pod with the help of cluster IP  

kubectl exec -it troubleshooting -- bash

nslookup app1

to check if it is doing balancing or not 
while true; do 
  curl -sL http://appl | grep -i 'IP Address'; 
  sleep 1; 
done

ku delete svc app1
delete deployment
-------------------------------------------------------------
in real-time container will not have each and every ppackage whateverwe require t
why create one troubleshooting container which contain all dependencies or packages    ---------------resume point 
ctl+siftp --formatt doc in vs code 

------------------------------------------------------------------------------------------------------------------------------------------------------------------ 
node port  
 
ku create deployment app1 --image kiran2361993/kubegame:v2 --replicas 3 --dry-run -o yaml

apiVersion: apps/v1
kind: Deployment
metadata: 
  name: appl Labelsels: 
    app: appl 
Spec: 
  replicas: 3
  Selector: 
    matchLabels:
      app: appl
  Template: 
    Metadata: 
      Labels: 
        App: appl  # Ensure the label matches the selector 
    spec:
      containers:
        - name: kubegame
          image: kiran2361993/kubegame:v2

deploy it
expose it

ku expose deployment appl --port 80 --target-port 80 --type NodePort

configure sg
access it 
delete svc only 
---------------------------------------------------------------------------------------------------------------------------------------
load balancer 

kubectl expose deployment appl --port 80 --target-port 80 --type LoadBalancer

-----------------------------------------------------------------------------------------------------------------------------------------
open rote53 - attachments name it - create record - simple routing - www - ip4 - load balancer - us-east-1 -  
---------------------------------------------------------------------------------------------------------------------------------------


apiVersion: v1
kind: Service
metadata:
  name: app 
  Labels: 
    app: app1
  Annotations: 
    service.beta.kubernetes.io/aws-load-balancer-type: "lb" 
    service.beta.kubernetes.io/aws-load-balancer-ccross-zoneload-balancing-enable: "true" 
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled: "true" 
    service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout: "30" Specc: 
  type: LoadBalancer 
  Selector: 
    app: app1
  Ports: 
    - port: 80
      targetPort: 80
      protocol: TCP

















